<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Probability distributions for Torch</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>
  <body>

      <div class="wrapper">
          <div id="navcontainer">
          <ul>
<li>
<a href="#toc_0">Probability distributions for Torch</a>
<ul>
<li>
<a href="#toc_1">Example</a>
<ul>
<li>
<a href="#toc_2">Getting/setting the seed and the state</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">Installation</a>
</li>
<li>
<a href="#toc_4">List of Distributions</a>
<ul>
<li>
<a href="#toc_5">Poisson: poisson</a>
<ul>
<li>
<a href="#toc_6">poisson.pdf(x, lambda)</a>
</li>
<li>
<a href="#toc_7">poisson.logpdf(x, lambda)</a>
</li>
<li>
<a href="#toc_8">poisson.cdf(x, lambda)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">Normal/Gaussian: norm</a>
<ul>
<li>
<a href="#toc_10">norm.pdf(x, mu, sigma)</a>
</li>
<li>
<a href="#toc_11">norm.logpdf(x, mu, sigma)</a>
</li>
<li>
<a href="#toc_12">norm.cdf(x, mu, sigma)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">Multivariate Normal: mvn</a>
<ul>
<li>
<a href="#toc_14">mnv.pdf(x, mu, M, [options])</a>
</li>
<li>
<a href="#toc_15">mvn.logpdf(x, mu, M, [options])</a>
</li>
<li>
<a href="#toc_16">mvn.rnd([res,] mu, M, [options])</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">Categorical/Multinomial: cat</a>
<ul>
<li>
<a href="#toc_18">cat.pdf(x, p, [options])</a>
</li>
<li>
<a href="#toc_19">cat.logpdf(x, p, [options])</a>
</li>
<li>
<a href="#toc_20">cat.rnd([res|N,] p, [options])</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">Multiple Categorical: mvcat</a>
<ul>
<li>
<a href="#toc_22">mvcat.pdf(x, p, [options])</a>
</li>
<li>
<a href="#toc_23">mvcat.logpdf(x, p, [options])</a>
</li>
<li>
<a href="#toc_24">mvcat.rnd([res|N,] p, [options])</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">Cauchy: cauchy</a>
<ul>
<li>
<a href="#toc_26">cauch.pdf(x, a, b)</a>
</li>
<li>
<a href="#toc_27">cauchy.logpdf(x, a, b)</a>
</li>
<li>
<a href="#toc_28">cauchy.cdf(x, a, b)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_29">Chi square: chi2</a>
<ul>
<li>
<a href="#toc_30">chi2.pdf(x, dof)</a>
</li>
<li>
<a href="#toc_31">chi2.logpdf(x, dof)</a>
</li>
<li>
<a href="#toc_32">chi2.cdf(x, dof)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">Laplace: laplace</a>
<ul>
<li>
<a href="#toc_34">laplage.pdf(x, loc, scale)</a>
</li>
<li>
<a href="#toc_35">laplace.logpdf(x, loc, scale)</a>
</li>
<li>
<a href="#toc_36">laplace.cdf(x, loc, scale)</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_37">Hypothesis Testing</a>
<ul>
<li>
<a href="#toc_38">ksone(x1, cdf)</a>
</li>
<li>
<a href="#toc_39">kstwo(x1, x2)</a>
</li>
<li>
<a href="#toc_40">chi2Uniform(x, [low, up, nBins])</a>
</li>
<li>
<a href="#toc_41">chi2TestCDF(x, cdf, cdfParams, [nBins])</a>
</li>
<li>
<a href="#toc_42">chi2Gaussian(x, mu, sigma, [nBins])</a>
</li>
</ul>
</li>
<li>
<a href="#toc_43">Unit Tests</a>
</li>
</ul>
</li>
</ul>

          </div>
          <section>
          <h1 id="toc_0">Probability distributions for Torch</h1>

<h2 id="toc_1">Example</h2>

<p>TODO</p>

<h3 id="toc_2">Getting/setting the seed and the state</h3>

<p>Distributions is transparently integrated with Torch&#39;s random stream: just use <code>torch.manualSeed(seed)</code>, <code>torch.getRNGState()</code>, and <code>torch.setRNGState(state)</code> as usual.</p>

<h2 id="toc_3">Installation</h2>

<p>From a terminal:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">luarocks install https://raw.github.com/jucor/torch-distributions/master/distributions-0-0.rockspec
</code></pre></div>
<h2 id="toc_4">List of Distributions</h2>

<h3 id="toc_5">Poisson: poisson</h3>

<h4 id="toc_6">poisson.pdf(x, lambda)</h4>

<p>Probability density function of a Poisson distribution with mean <code>lambda</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_7">poisson.logpdf(x, lambda)</h4>

<p>Log of probability density function of a Poisson distribution with mean <code>lambda</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_8">poisson.cdf(x, lambda)</h4>

<p>Cumulative distribution function of a Poisson distribution with mean <code>lambda</code>, evaluated at <code>x</code>.</p>

<h3 id="toc_9">Normal/Gaussian: norm</h3>

<h4 id="toc_10">norm.pdf(x, mu, sigma)</h4>

<p>Probability density function of a Normal distribution with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_11">norm.logpdf(x, mu, sigma)</h4>

<p>Log probability density function of a Normal distribution with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_12">norm.cdf(x, mu, sigma)</h4>

<p>Cumulative distribution function of a Normal distribution with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code>.</p>

<h3 id="toc_13">Multivariate Normal: mvn</h3>

<p>The covariance matrix passed to multivariate gaussian functions needs only be positive <strong>semi</strong>-definite: we deal gracefully with the degenerate case of rank-deficient covariance. </p>

<p>Those functions also accept the upper-triangular Cholesky decomposition instead, by setting the field <code>cholesky = true</code> in the optional table <code>options</code>.</p>

<h4 id="toc_14">mnv.pdf(x, mu, M, [options])</h4>

<p>Probability density function of a multivariate Normal distribution with mean <code>mu</code> and covariance or cholesky of the covariance specified in <code>M</code>, evaluated at <code>x</code>. </p>

<p>By defaut, the matrix <code>M</code> is the covariance matrix. However, it is possible to pass the upper-triangular Cholesky decomposition instead, by setting the field <code>cholesky = true</code> in the optional table <code>options</code>.</p>

<p>For a D-dimensional Normal, the following forms are valid:</p>

<ul>
<li><code>mvn.pdf([D], [D], [D, D])</code> - returns a number.</li>
<li><code>mvn.pdf([N, D], [D], [D, D])</code> - returns a Tensor.</li>
<li><code>mvn.pdf([D], [N, D], [D, D])</code> - returns a Tensor.</li>
<li><code>mvn.pdf([N, D], [N, D], [D, D])</code> - returns a Tensor.</li>
</ul>

<p>In the case of a diagonal covariance <code>cov</code>, you may also opt to pass a vector containing only the diagonal elements:</p>

<ul>
<li><code>mvn.pdf([D], [D], [D])</code> - returns a number.</li>
<li><code>mvn.pdf([N, D], [D], [D])</code> - returns a Tensor.</li>
<li><code>mvn.pdf([D], [N, D], [D])</code> - returns a Tensor.</li>
<li><code>mvn.pdf([N, D], [N, D], [D])</code> - returns a Tensor.</li>
</ul>

<h4 id="toc_15">mvn.logpdf(x, mu, M, [options])</h4>

<p>Probability density function of a multivariate Normal distribution with mean <code>mu</code> and covariance matrix <code>M</code>, evaluated at <code>x</code>.</p>

<p>See <code>mvn.pdf()</code> for description of valid forms for x, mu and cov and options.</p>

<h4 id="toc_16">mvn.rnd([res,] mu, M, [options])</h4>

<p>Sample from a multivariate Normal distribution with mean <code>mu</code> and covariance matrix <code>M</code>.</p>

<p>For a D-dimensional Normal, the following forms are valid:</p>

<ul>
<li><code>mvn.rnd([D], [D, D])</code> - returns 1 sample in a 1-by-D Tensor</li>
<li><code>mvn.rnd([N, D], [D, D])</code> - returns N samples in a N-by-D Tensor</li>
<li><code>mvn.rnd([N, D], [D], [D, D])</code> - stores and returns N samples in the N-by-D Tensor</li>
<li><code>mvn.rnd([N, D], [N, D], [D, D])</code> - stores and returns N samples in the N-by-D Tensor</li>
</ul>

<p>In the case of a diagonal covariance <code>cov</code>, you may also opt to pass a vector (not a matrix) containing only the diagonal elements.</p>

<p>By defaut, the matrix <code>M</code> is the covariance matrix. However, it is possible to pass the upper-triangular Cholesky decomposition instead, by setting the field <code>cholesky = true</code> in the optional table <code>options</code>.</p>

<h3 id="toc_17">Categorical/Multinomial: cat</h3>

<p>Categorical distributions on indices from 1 to K = p:numel().</p>

<p>Not vectorized in p. See mvcat for vectorized version.</p>

<h4 id="toc_18">cat.pdf(x, p, [options])</h4>

<p>Not implemented</p>

<h4 id="toc_19">cat.logpdf(x, p, [options])</h4>

<p>Not implemented</p>

<h4 id="toc_20">cat.rnd([res|N,] p, [options])</h4>

<p>Sample <code>N = size(res,1)</code> amongst <code>K = 1 ... p:numel()</code>, where the probability of category k is given by p[k]/p:sum().</p>

<p>Options is a table containing:</p>

<ul>
<li><p>options.type Type of sampler:</p>

<ul>
<li><code>nil</code> or <code>&#39;iid&#39;</code>: default, i.i.d samples, use linear search in O(N log N + max(K, N)), best when K/N is close to 1.</li>
<li>&#39;dichotomy&#39;: dichotomic search, same variance, faster when small K large N</li>
<li>&#39;stratified&#39;: sorted stratified samples, sample has lower variance than i.i.d. but not independent, best when K/N is close to 1</li>
</ul></li>
<li><p>options.categories Categories to sample from</p>

<ul>
<li><code>nil</code>: default, returns integers between 1 and K</li>
<li>K-by-D tensor: each row is a category, must have has many rows as p:numel()</li>
</ul></li>
</ul>

<p>Returns a LongTensor vector with N elements in the resulting tensor if no categories is given,
or a new tensor of N rows corresponding to the categories given.</p>

<p>Note that it is not yet possible to use a result tensor <em>and</em> categories at the same time. This will be possible once <a href="https://github.com/torch/torch7-distro/issues/202">torch&#39;s index() accepts result tensor</a>.</p>

<h3 id="toc_21">Multiple Categorical: mvcat</h3>

<p>Vectorized version of <code>cat</code>, where <code>p</code> is now a matrix where each row represents a vector of probabilities. It samples independently for each row of <code>p</code>.</p>

<h4 id="toc_22">mvcat.pdf(x, p, [options])</h4>

<p>Not implemented</p>

<h4 id="toc_23">mvcat.logpdf(x, p, [options])</h4>

<p>Not implemented</p>

<h4 id="toc_24">mvcat.rnd([res|N,] p, [options])</h4>

<p>For each row <code>r = 1 ... R</code> of the matrix <code>p</code>, sample <code>N = size(res, 2)</code> amongst <code>K = 1 ... p:size(2)</code>, where the probability of category k is given by p[r][k]/p:sum(1).</p>

<p>Options is a table containing:</p>

<ul>
<li>options.type Type of sampler:

<ul>
<li><code>nil</code> or <code>&#39;iid&#39;</code>: default, i.i.d samples, use linear search in O(N log N + max(K, N)), best when K/N is close to 1.</li>
<li>&#39;dichotomy&#39;: dichotomic search, same variance, faster when small K large N</li>
<li>&#39;stratified&#39;: sorted stratified samples, sample has lower variance than i.i.d. but not independent, best when K/N is close to 1</li>
</ul></li>
</ul>

<p>Returns a LongTensor vector with R-by-N elements in the resulting tensor.
or a new tensor of R rows with N columns corresponding to the categories given.</p>

<p>Note that <code>mvcat</code>, unlike <code>cat</code>, only returns tensor of integers: it does not allow for specifying a tensor of categories, to keep the handling of dimensions simple.</p>

<h3 id="toc_25">Cauchy: cauchy</h3>

<h4 id="toc_26">cauch.pdf(x, a, b)</h4>

<p>Probability density function of a Cauchy distribution with location <code>a</code> and scale <code>b</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_27">cauchy.logpdf(x, a, b)</h4>

<p>Log of probability density function of a Cauchy distribution with location <code>a</code> and scale <code>b</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_28">cauchy.cdf(x, a, b)</h4>

<p>Cumulative distribution function of a Cauchy distribution with location <code>a</code> and scale <code>b</code>, evaluated at <code>x</code>.</p>

<h3 id="toc_29">Chi square: chi2</h3>

<h4 id="toc_30">chi2.pdf(x, dof)</h4>

<p>Probability density function of a Chi square distribution with <code>dof</code> degrees of freedom, evaluated at <code>x</code>.</p>

<h4 id="toc_31">chi2.logpdf(x, dof)</h4>

<p>Log of probability density function of a Chi square distribution with <code>dof</code> degrees of freedom, evaluated at <code>x</code>.</p>

<h4 id="toc_32">chi2.cdf(x, dof)</h4>

<p>Cumulative distribution function of a Chi square distribution with <code>dof</code> degrees of freedom, evaluated at <code>x</code>.</p>

<h3 id="toc_33">Laplace: laplace</h3>

<h4 id="toc_34">laplage.pdf(x, loc, scale)</h4>

<p>Probability density function of a Laplace distribution with location <code>loc</code> and scale <code>scale</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_35">laplace.logpdf(x, loc, scale)</h4>

<p>Log of probability density function of a Laplace distribution with location <code>loc</code> and scale <code>scale</code>, evaluated at <code>x</code>.</p>

<h4 id="toc_36">laplace.cdf(x, loc, scale)</h4>

<p>Cumulative distribution function of a Laplace distribution with location <code>loc</code> and scale <code>scale</code>, evaluated at <code>x</code>.</p>

<h2 id="toc_37">Hypothesis Testing</h2>

<p>Besides the generators, there are some functions for checking whether two samples come from the same unspecified distribution using <a href="http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test#Two-sample_Kolmogorov.E2.80.93Smirnov_test"><code>Kolmogorov-Smirnov two-sample test</code></a>, and whether a sample fits a particular distribution, using <a href="http://en.wikipedia.org/wiki/Pearson&#x27;s_chi-squared_test"><code>Pearson&#39;s chi-squared test</code></a>.</p>

<h3 id="toc_38">ksone(x1, cdf)</h3>

<p>Perform a one-sample Kolmogorov-Smirnov test, with null hypothesis &quot;sample x comes from the distribution whose cumulative distribution function is given&quot;.</p>

<ul>
<li><code>x</code> should be a vector of sample values to test</li>
<li><code>cdf</code> should be a function that takes a number and return the cumulative distribution function at this point</li>
</ul>

<p>Returns: <code>p</code>, <code>d</code> - the p-value and the statistic the test, respectively.</p>

<h3 id="toc_39">kstwo(x1, x2)</h3>

<p>Perform a two-sample Kolmogorov-Smirnov test, with null hypothesis &quot;sample x1 and sample x2 come from the same distribution&quot;.</p>

<ul>
<li><code>x1</code> should be a vector of sample values to test </li>
<li><code>x2</code> should be a vector of sample values to test </li>
</ul>

<p>Returns: <code>p</code>, <code>d</code> - the p-value and the statistic the test, respectively.</p>

<h3 id="toc_40">chi2Uniform(x, [low, up, nBins])</h3>

<p>Perform a chi-squared test, with null hypothesis &quot;sample x is from a continuous uniform distribution on the interval <code>[low, up]</code>&quot;.</p>

<ul>
<li><code>x</code> should be a vector of sample values to test</li>
<li><code>low</code> is the lower end of the uniform distribution&#39;s support interval (default: 0)</li>
<li><code>up</code> is the upper end of the uniform distribution&#39;s support interval (default: 1)</li>
<li><code>nBins</code> is number of frequency buckets to use for the test (default: 100)</li>
</ul>

<p>Returns: <code>p</code>, <code>chi2</code> - the p-value and the chi-squared score of the test, respectively.</p>

<h3 id="toc_41">chi2TestCDF(x, cdf, cdfParams, [nBins])</h3>

<p>Perform a chi-squared test, with null hypothesis &quot;sample x is from a distribution with cdf <code>cdf</code>, parameterised by <code>cdfParams</code>&quot;.</p>

<ul>
<li><code>x</code> should be a vector of sample values to test</li>
<li><code>cdf</code> should be a function which takes a number of parameters followed by a sample value and returns the cumulative density of the distribution up to that point</li>
<li><code>cdfParams</code> should be a table of parameters which will be passed to <code>cdf</code></li>
<li><code>nBins</code> is number of frequency buckets to use for the test (default: 100)</li>
</ul>

<p>Returns: <code>p</code>, <code>chi2</code> - the p-value and the chi-squared score of the test, respectively.</p>

<h3 id="toc_42">chi2Gaussian(x, mu, sigma, [nBins])</h3>

<p>Perform a chi-squared test, with null hypothesis &quot;sample x is from a Normal distribution with mean <code>mu</code> and variance <code>sigma</code>&quot;.</p>

<ul>
<li><code>x</code> should be a vector of sample values to test</li>
<li><code>mu</code> should be a number - the mean</li>
<li><code>sigma</code> should be a positive number - the variance</li>
<li><code>nBins</code> is number of frequency buckets to use for the test (default: 100)</li>
</ul>

<p>Returns: <code>p</code>, <code>chi2</code> - the p-value and the chi-squared score of the test, respectively.</p>

<h2 id="toc_43">Unit Tests</h2>

<p>Last but not least, the unit tests are in the folder
<a href="https://github.com/jucor/torch-distributions/tree/master/luasrc/tests"><code>luasrc/tests</code></a>. You can run them from your local clone of the repostiory with:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">git clone https://www.github.com/jucor/torch-distributions
find torch-distributions/luasrc/tests -name <span class="s2">&quot;test*lua&quot;</span> -exec torch <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div>
<p>Those tests will soone be automatically installed with the package, once I sort out a bit of CMake resistance.</p>

          </section>
      </div>
      <script src="javascripts/scale.fix.js"></script>
  </body>
</html>
